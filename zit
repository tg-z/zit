#!/usr/bin/env bash
###############################################################################
# zit - a zettelkasten management tool
#
# get bask:
#   https://github.com/xwmx/bask
# get zit:
#   https://github.com/tg-z/zit
#
# add this script and the bask program to your $PATH.
#
# For usage information, run:
#   zit help
###############################################################################

# load bask

# https://github.com/koalaman/shellcheck/wiki/SC1090
# shellcheck source=/dev/null

set -o nounset
set -o errexit
set -o pipefail
IFS=$'\n\t'

DEFAULT_COMMAND="${DEFAULT_COMMAND:-help}"
export zettel_id_format="$(date +%Y%m%d%H%M%S)"
export ZET_ID="${zettel_id_format}"
export zettel_title="${1:-new-zettel}"
export zettel_date_format="$(date +"%B %d, %Y")"
export zettel_tag_format="$(date +%Y)"

export ZET_ID="${zettel_id_format}"
export ZET_TITLE="${zettel_title}"
export ZET_DATE="${zettel_date_format}"
export ZET_TAGS="${zettel_tag_format}"


source "$(command -v bask)"

desc "init" <<HEREDOC
Usage:
  $_ME init

Description:
  With no argument, checks if ZETTEL_DIR exists. If it has not been set up yet it will create a directory in the XDG_DATA_HOME called zet.
HEREDOC

desc "list" <<HEREDOC
Usage:
  $_ME ls|[list]

Description:
  With no argument, list all notes. Otherwise list notes containing any of the given patterns.
HEREDOC

_command_exists() {
  hash "${1}" 2>/dev/null
}
_function_exists() {
  [[ "$(type -t "${1:-}")" == 'function' ]]
}
is_in_git_repo() {
  git rev-parse HEAD > /dev/null 2>&1
}
_contains() {
  local _query="${1:-}"
  shift

  if [[ -z "${_query}"  ]] ||
     [[ -z "${*:-}"     ]]
  then
    return 1
  fi

  for __element in "${@}"
  do
    [[ "${__element}" == "${_query}" ]] && return 0
  done

  return 1
}
init() {
  echo ">> hi from zit!"
  if [ -z "$ZETTEL_DIR" ]; then
	echo "setup your zettel by adding 'export ZETTEL_DIR='~/.local/share/zet'' or add something similar to your zshrc/bashrc."
	echo "by default, the directory is set to ${XDG_DATA_HOME:-$HOME/.local/share}/zet"
  exit 1
  elif [ -d "$ZETTEL_DIR" ]; then
	echo ">> your zettel is set up + ready to go :)"
  else 
	echo ">> you still need to create the directory."
  fi
}

list() {
    cd "${ZETTEL_DIR}"
    fd 20 | sd '.md' '' | sd '-' ' '
}

new() {
    cd "${ZETTEL_DIR}"
    source "${0%/*}"/lib/mo
cat <<EOF | mo
---
id: {{ZET_ID}}
title: {{ZET_TITLE}}
date: {{ZET_DATE}}
tags: {{ZET_TAGS}}
---

# {{ZET_TITLE}}

EOF
}

desc "tags" <<HEREDOC
Usage:
  $_ME t|tags [TAG [TAG ...]]

Description:
  With no argument, list all tags found in notes. Otherwise list all notes containing any of the given tags.
HEREDOC

desc "new" <<HEREDOC
Usage: $_ME n|new <TITLE>

Description:
  Create a new note with the given title.
HEREDOC

tags() {
	local zettels
	zettels="$(fd 20 -e md "$ZETTEL_DIR" | fgrep "$tags")"
	local tags
	tags="$(awk '/^tags:/ {$1="";print}' "$ZETTEL_DIR"/* | tr ',' '\n' | awk '{$1=$1}1' | sort -u)"
	while IFS='' read -r line; do
	    COMPREPLY+=("$line")
	done < <(printf )
}

# tags() {
#   local zettels
#   zettels=$(compgen -f "$ZETTEL_DIR/" | sed -E -e 's/.*\///g' -e '/^[0-9]{14}/!d' -e 's/\..*$//'

#   case "${COMP_WORDS[1]}" in
# 	  bl|backlinks|s|sh|show|o|open|p|pre|prev|preview)
# 		  # compgen only returns prefix-matches, but we want to return
# 		  # matches anywhere in the substring, so use grep to generate the
# 		  # results
# 		  while IFS='' read -r line; do
# 			  COMPREPLY+=("$line")
# 		  done < <(printf '%s\n' "$zettels" | grep -iF "$cur")
# 		  ;;
#   local tags
#   tags=$(awk '/^tags:/ {$1="";print}' "$ZETTEL_DIR"/* | tr ',' '\n' | awk '{$1=$1}1' | sort -u)
#   # Prioritize prefix matches but if none exist, fallback to matching any substring
#   matches=$(compgen -W "$tags" -- "$cur")
#   if [ -z "$matches" ]; then
#     matches=$(printf '%s\n' "$tags" | grep -iF "$cur")
#   fi

#   while IFS='' read -r line; do
# 	  COMPREPLY+=("$line")
#   done < <(printf '%s\n' "$matches")
# }
_init
